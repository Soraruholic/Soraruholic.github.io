[{"content":"解法一(可读性): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Solution { public: ListNode* deleteDuplicates(ListNode* head) { // Special Case 1: Empty List if (head == nullptr) { return nullptr; } // Special Case 2: Only One Element (No Duplicates) if (head-\u0026gt;next == nullptr) { return head; } // Special Case 3: Two Elements (Return Either None or Self) if (head-\u0026gt;next-\u0026gt;next == nullptr) { if (head-\u0026gt;val == head-\u0026gt;next-\u0026gt;val) { return nullptr; } else { return head; } } // Initialzing pointers ListNode* pseudo_head = new ListNode(-777, head); ListNode* last_different = pseudo_head; ListNode* candidate = head; ListNode* preception = candidate-\u0026gt;next; // Initializing the indicator int indicator = candidate-\u0026gt;val == preception-\u0026gt;val ? candidate-\u0026gt;val : -777; // Setting end-loop condition while (preception != nullptr || (candidate != nullptr \u0026amp;\u0026amp; candidate-\u0026gt;val == indicator)) { // Deleting duplicates if (candidate-\u0026gt;val == indicator) { // duplicate_head = indicator == head-\u0026gt;val; last_different-\u0026gt;next = preception; candidate = preception; preception = preception ? preception-\u0026gt;next : nullptr; } else { last_different = candidate; candidate = preception; preception = preception-\u0026gt;next; } // Updating indicator if (preception != nullptr \u0026amp;\u0026amp; preception-\u0026gt;val == candidate-\u0026gt;val) { indicator = preception-\u0026gt;val; } } return pseudo_head-\u0026gt;next; } }; 解法二(简洁): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: ListNode* deleteDuplicates(ListNode* head) { // Special Case: Empty List if (head == nullptr) { return nullptr; } // Initialzing pointers ListNode* pseudo_head = new ListNode(-777, head); ListNode* cur = pseudo_head; while (cur-\u0026gt;next != nullptr \u0026amp;\u0026amp; cur-\u0026gt;next-\u0026gt;next != nullptr) { if (cur-\u0026gt;next-\u0026gt;val == cur-\u0026gt;next-\u0026gt;next-\u0026gt;val) { int idx = cur-\u0026gt;next-\u0026gt;val; while (cur-\u0026gt;next != nullptr \u0026amp;\u0026amp; idx == cur-\u0026gt;next-\u0026gt;val) { cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; } } else { cur = cur-\u0026gt;next; } } return pseudo_head-\u0026gt;next; } }; ","date":"2024-01-15T00:00:00Z","image":"https://Soraruholic.github.io/p/leetcode-daily-24-01-15/1_huf8b66cde27ea8cf94061391817f76881_11173_120x120_fill_box_smart1_3.png","permalink":"https://Soraruholic.github.io/p/leetcode-daily-24-01-15/","title":"Jan 15 2024 LeetCode Daily"},{"content":"基本内置类型 算术类型 两类算术类型：\n整型：字符，布尔，整型(有符号、无符号)，长整型，\u0026hellip; 浮点型：单精度、双精度、扩展精度，\u0026hellip; 长整型 long long在Cpp11中新定义\n类型转换 非布尔类型的算术值赋给布尔类型：0 -\u0026gt; false, otherwise -\u0026gt; true 布尔类型转非布尔类型：false -\u0026gt; 0, true -\u0026gt; 1 浮点数赋给整数：仅保留小数点之前的部分 整数赋给浮点数：小数部分记为0，有精度损失风险 超过范围的数赋给无符号：对能表示的最大值取模 超过范围的数赋给有符号：未定义行为 在表达式中，有符号数遇到无符号数会自动转化为无符号数。\n字面值常量 整型与浮点型字面值： 整型：十进制、八进制(0开头)、十六进制(0x或0X开头)。 默认情形下，十进制字面值是带符号整型，八/十六进制未定。前提是当前类型可以容纳该数值(最小为int，因此不存在short类型的整型字面值)。 十进制不会是负数：-12表示对字面值12取负值。 浮点数：小数或者科学计数法表示的小数，指数部分用E或者e表示，默认为double。 字符和字符串字面值 字符串字面值是常量字符构成的数组，结尾处由编译器添加一个空字符\\0。 如果两个字符串字面值位置紧邻，且仅由空格、缩进和换行符分隔，则整体视为一个字符串字面值。 转义序列 不能直接使用的字符：不可打印字符和特殊含义字符(', \u0026quot;, ?, \\) 泛化转义序列： \\x后紧跟一个或者多个十六进制数字：字符大小取决于所包含的十六进制数对应的比特数(超过char大小直接使用可能报错)，通常与前缀一同使用。 \\后紧跟1~3个八进制数字。 指定字面值的类型 1 2 3 4 5 6 L\u0026#39;a\u0026#39; // 宽字符型字面值(wchar_t)，2或4字节大小 u8\u0026#34;hi!\u0026#34; // utf-8字符串字面值，每个Unicode大小为8位 3.1415926L // 扩展精度浮点数字面值(long double) // 无符号整型字面值(unsigned long long)，U/u表示无符号，LL/ll表示long long，L/l表示long 42ULL 布尔字面值和指针字面值 布尔字面值：true与false 指针字面值：nullptr ​\n","date":"2023-12-19T00:01:00Z","image":"https://Soraruholic.github.io/p/cpp-11-primer-2-1/1_hu6c1a497bfd8e6636377831810b18c9b4_629716_120x120_fill_box_smart1_3.png","permalink":"https://Soraruholic.github.io/p/cpp-11-primer-2-1/","title":"2.1 基本内置类型"},{"content":"复合类型 主要分析两种复合类型：引用和指针。\n引用 引用等价于为对象起了别名，通过将声明符写作\u0026amp;variable的形式来定义引用类型。 定义引用时，初始值与引用绑定在一起，而不是将初始值拷贝到新建的引用中。 引用必须初始化，并且一旦引用完成初始化，便无法与另一个对象重新绑定。 引用即别名 引用不是一个对象，所有对引用的操作都是在与之绑定的对象上进行。 1 2 3 4 5 6 7 int v = 1024; int \u0026amp;ref = v; // 正确，v的值与ref进行绑定 int \u0026amp;ref2; // 错误，引用必须初始化 ref = 2; // 等同于 \u0026#34;v = 2;\u0026#34; int v2 = ref; // 等同于 \u0026#34;int v2 = v;\u0026#34; int \u0026amp;ref2 = ref; // 等同于 \u0026#34;int \u0026amp;ref2 = v;\u0026#34; 不能定义引用的引用。 1 int \u0026amp; \u0026amp;x = v; // 错误，不能引用未分配内存的对象，即不能定义引用的引用 引用的定义 允许一条语句中定义多个引用，但每个引用必须以\u0026amp;开头。 除部分特例，引用的类型须与其绑定的对象严格匹配。 引用只能绑定在对象上，不能是字面值或者表达式结果。 1 2 3 4 5 6 int i1 = 1024, i2 = 2048; int \u0026amp;r1 = i1, \u0026amp;r2 = i2; // 声明r2引用时必须用\u0026amp;开头 int \u0026amp;r3 = 10; // 错误，引用只能与对象绑定，不能是字面值 double f1 = 3.14; int \u0026amp;r4 = f1; // 错误，引用的类型必须和绑定的对象保持一致 指针 定义指针类型将声明符写成*variable的形式，如果在一个语句中定义多个指针，则每个指针变量都以*开头。 在块作用域内定义的指针如果未初始化，则是未定义的。 指针和引用都能提供对其他对象的间接访问。 指针与引用的区别 指针本身就是一个对象，引用不是。 指针在生命周期内可以先后指向不同对象，引用则只能与对象绑定一次。 指针无须在定义时初始化，引用必须初始化。 获取对象的地址 取地址符\u0026amp;：获取对象的地址，保存在指针之中。 引用不是对象，所以不可以定义指向引用的指针。 除了部分特例，指针的类型需与其指向的对象严格匹配。 1 2 3 4 double d; double *pd1 = \u0026amp;d; // 正确，初始化一个指向变量d的double型指针 double *pd2 = pd1; // 正确，同样初始化一个指向变量d的指针 int *pi1 = \u0026amp;d; // 错误，指针类型与所指向的对象不匹配 指针值 指针的值应属于下列4种状态之一：\n指向一个对象；\n指向紧邻对象所占空间的下一个位置；\n空指针：不指向任何对象；\n无效指针。\n试图拷贝或以其他方式访问无效指针将引发错误，并且编译器不负责检查此类错误(即不会发出warning或者报错)\n利用指针访问对象 解引用符*：作用于指针，用以访问其所指向的对象。 对指针解引用的结果进行赋值，本质上就是对指针指向的对象赋值。 1 2 3 int i = 42; int *p = \u0026amp;i; *p = 0; // 等价于将变量i赋值为0 解引用前必须确认该指针确实指向了一个对象。 空指针 空指针不指向任何对象，在使用一个指针之前最好检查其是否为空指针。 生成空指针的若干方法： 1 2 3 4 5 int *p1 = nullptr; // 等价于 int *p1 = 0; int *p2 = 0; // 必须是字面值常量0，不能是值为0的int型变量 #include \u0026lt;cstdlib\u0026gt; int *p3 = NULL; // 等价于 int *p3 = 0; 不能将int型变量直接赋值给指针，即便该变量的值为0。 赋值和指针 指针可以反复赋值，而引用则不行。 注意区分赋值时，等号左边的是指针所指向的对象还是指针自身。 1 2 3 4 5 int i = 42; int *p = 0; // 初始化整型指针p，将其置为空指针 p = \u0026amp;i; // 将指针p赋值为i的地址，使其指向变量i *p = 0; // 对指针p所指向的对象i进行赋值，等价于 i = 0; p = 0; // 对指针p进行赋值，将其重置为空指针 其他指针操作 如果指针的值是0(即空指针)，则其对应的条件值为false，反之则为true。 可以用相等操作符比较两个类型相同的合法指针，比较的结果是布尔类型，比较的内容则是二者存放的地址。若两指针相等，则： 都为空指针； 指向同一个对象； 对象同一个对象的下一个地址； (可能出现) 一个指针指向某对象，另一指针指向另一个对象的下一地址。 void* 指针 用于存放任意对象的地址。 不能直接操作void*指针所指向的对象，因不知其所指向的对象的类型。 1 2 3 4 5 6 7 double obj = 3.14, *pd = \u0026amp;obj; void *pv = \u0026amp;obj; // 可以指向任意类型的对象 cout \u0026lt;\u0026lt; *(double*)pv; // 不能直接打印pv的值，必须首先将其转化为固定类型的指针 pv = \u0026amp;pd; // 可以指向任意类型的指针(指针自身也是一个对象) cout \u0026lt;\u0026lt; **(double**)pv; // 双重指针可以两次解引用，结果为pd指向的变量obj(值为3.14) 理解复合类型的声明 定义多个变量 变量的定义包含一个基本数据类型和一组声明符，即在一条语句中，基本数据类型只有一个，但是声明符的形式可以不同。 类型修饰符属于声明符的一部分，因此一条语句可以定义出不同类型的结果。 1 2 int i = 1024, *p = \u0026amp;i, \u0026amp;r = i; // 其中(*p = \u0026amp;i)整体为一个声明符，(\u0026amp;r = i)为另一个，声明符之间用逗号隔开 指针和引用的声明有两种写法，一种是将修饰符与变量写在一起，另一种是将修饰符与类型名写在一起。 1 2 int *p1; int* p1; 指向指针的指针 指针修饰符可以叠加，用以表示存放指针地址的指针，即指向指针的指针。 1 2 3 4 int i = 1024; int *p = \u0026amp;i; int **pp = \u0026amp;p; // 声明一个指向指针p的指针pp，通过pp指针访问i的值时，需要两次解引用**pp 指向指针的引用 指针是一个对象，因此可以定义对指针的引用 1 2 3 4 5 6 7 int i = 42; int *p = \u0026amp;i; int *\u0026amp;r = p; // 声明对指针p的引用 r = \u0026amp;i; // 使得p指针指向i，等价于 p = \u0026amp;i; *r = 0; // 修改p指针指向对象的值，等价于 *p = 0; r = 0; // 将指针p重置为空指针。 面对多重指针和引用的复合类型，可以从右向左的阅读其修饰符列表，距离变量名最近的修饰符对变量有最直接的影响(若为\u0026amp;则是引用，为*就表示指针)，其余部分则用以确定其指向/引用的类型。 ","date":"2023-12-19T00:01:00Z","image":"https://Soraruholic.github.io/p/cpp-11-primer-2-3/1_hu6c1a497bfd8e6636377831810b18c9b4_629716_120x120_fill_box_smart1_3.png","permalink":"https://Soraruholic.github.io/p/cpp-11-primer-2-3/","title":"2.3 复合类型"},{"content":"变量 变量定义 基本形式：类型说明符 + [变量名+初始化(可选)] (一个或者多个，彼此之间用逗号相隔)。 CPP Primer此处对于变量定义的语法比较模棱两可，并未考虑复杂的情形，详细的变量声明的文法可见C++11的官方标准。\n初始值 初始化：对象在创建的同时获得了特定的值(初始值)。 可以用任意复杂的表达式作为初始值。 可以迭代初始化： 1 double price = 1.14, discount = 514. * price; 初始化不是赋值，后者需要先将对象的当前值擦除，而后用新值替代。 列表初始化 多种初始化形式: 1 2 3 4 5 6 int x = 0; int x(0); // 列表初始化 int x = {0}; int x{0}; 使用列表初始化时，如果初始值存在丢失信息的风险，则编译器将报错： 1 2 3 long double pi = 3.1415926536; int a{pi}, b = {pi}; // 编译报错(也可能是Warning)，存在精度损失 int a(pi), b = pi; // 编译通过 默认初始化 内置类型若未被显式初始化， 若其定义在函数体内部，该变量不被初始化，其值是未定义的； 否则，将被初始化为0。 每个类各自决定初始化对象的方式。 变量声明与定义的关系 分离式编译：将程序分割为若干个文件，使得每个文件可被独立编译。 为了支持分离式编译，C++将变量的声明和定义区分， 声明使得变量为程序所知，每个文件使用变量前必须包含对其的声明； 定义负责创建与变量相关的实体。 若想在文件中声明一个变量，而该变量在其他文件中定义，可以在声明时加入关键字extern，并且不进行显式初始化： 1 extern long double pi; 如果使用extern的同时对变量进行定义(初始化)，那么extern关键字将失效，或者直接报错(对于同一变量的重复定义)。 变量只能被定义一次，却可以多次被声明。 标识符 标识符由字符、数字和下划线，并且数字不能作为开头。 标识符没有长度限制，但是对大小写敏感。 变量命名规范 基本规范此处不做详述，选取最合适的现行规范使用即可。 用户自定义标识符不连续出现两个下划线。 不以下划线紧连大写字母开头。 定义在函数体外的标识符不以下划线开头。 名字的作用域 变量的有效区域始于其声明语句，终结于声明语句所在的作用域末端。 大多是作用域以花括号分隔。 全局作用域：定义在函数体之外，一旦声明之后，全局作用域内的变量在整个程序范围内都可用。 块作用域：仅在声明语句之后，且在声明语句的作用域内可用。 嵌套的作用域 外层作用域可以包含内层作用域。 ","date":"2023-12-19T00:00:00Z","image":"https://Soraruholic.github.io/p/cpp-11-primer-2-2/1_hu6c1a497bfd8e6636377831810b18c9b4_629716_120x120_fill_box_smart1_3.png","permalink":"https://Soraruholic.github.io/p/cpp-11-primer-2-2/","title":"2.2 变量"},{"content":"Welcome to Hugo theme Stack. This is your first post. Edit or delete it, then start writing!\nFor more information about this theme, check the documentation: https://stack.jimmycai.com/\nWant a site like this? Check out hugo-theme-stack-stater\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2022-03-06T00:00:00Z","image":"https://Soraruholic.github.io/p/hello-world/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://Soraruholic.github.io/p/hello-world/","title":"Hello World"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"https://Soraruholic.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-26T00:00:00Z","image":"https://Soraruholic.github.io/p/image-gallery/2_hubce42636ecacc1a380b462f3110efcec_37455_120x120_fill_q75_box_smart1.jpg","permalink":"https://Soraruholic.github.io/p/image-gallery/","title":"Image gallery"},{"content":"For more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash\n","date":"2023-08-25T00:00:00Z","image":"https://Soraruholic.github.io/p/shortcodes/cover_huec3c3e34981507583e214021ad1b9a4b_12942_120x120_fill_q75_box_smart1.jpg","permalink":"https://Soraruholic.github.io/p/shortcodes/","title":"Shortcodes"},{"content":"Stack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi),e^{2 \\pi i \\xi x},d\\xi $$\n1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ ","date":"2023-08-24T00:00:00Z","permalink":"https://Soraruholic.github.io/p/math-typesetting/","title":"Math Typesetting"}]